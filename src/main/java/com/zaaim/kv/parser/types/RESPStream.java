package com.zaaim.kv.parser.types;

import java.util.*;
import java.util.stream.Collectors;

public class RESPStream {
    private List<RespStreamEntry> entries = new ArrayList<>();
    String previousStreamEntryId = "";

    public RESPStream() {}

    public RespStreamEntry getStreamEntry(String streamEntryId) {
        return entries.stream()
                .filter(se -> se.getId().equals(streamEntryId))
                .findFirst()
                .orElse(null);
    }

    public RespStreamEntry getLastStreamEntry() {
        if (entries.isEmpty()) return null;
        return entries.getLast();
    }

    public void addStreamEntry(RespStreamEntry streamEntry) {
        RespStreamEntry lastStreamEntry = getLastStreamEntry();
        if (lastStreamEntry != null) {
            previousStreamEntryId = lastStreamEntry.getId();
        } else {
            previousStreamEntryId = streamEntry.getId();
        }
        entries.add(streamEntry);
    }

    public String getPreviousStreamEntryId() {
        return previousStreamEntryId;
    }

    public List<RespStreamEntry> getStreamEntriesWithinRange(String startId, String endId) {
        final long startIdMilliSecondsPart;
        final long startIdSequenceNoPart;
        final long endIdMilliSecondsPart;
        final long endIdSequenceNoPart;
        boolean getFromStart = startId.equals("-");
        boolean getUntilEnd = endId.equals("+");
        String[] startIdParts = startId.split("-");
        String[] endIdParts = endId.split("-");

        if (getFromStart) {
            startIdMilliSecondsPart = 0;
        } else {
            startIdMilliSecondsPart = Long.parseLong(startIdParts[0]);
        }

        if (getUntilEnd) {
            endIdMilliSecondsPart = getLastStreamEntry().getSequenceNoIdPart();
        } else {
            endIdMilliSecondsPart = Long.parseLong(endIdParts[0]);
        }

        boolean isOnlyComparingMilliSecondsIdPart = startIdParts.length == 1 || (endIdParts.length == 1 && !getUntilEnd);

        if (!isOnlyComparingMilliSecondsIdPart) {
            startIdSequenceNoPart = getFromStart ? 0 : Long.parseLong(startIdParts[1]);
            endIdSequenceNoPart = getUntilEnd ? getLastStreamEntry().getSequenceNoIdPart() :  Long.parseLong(endIdParts[1]);
        } else {
            startIdSequenceNoPart = 0;
            endIdSequenceNoPart = 0;
        }

        return entries.stream()
                .filter(
                        e -> (
                                e.getMilliSecondsIdPart() >= startIdMilliSecondsPart &&
                                        e.getMilliSecondsIdPart() <= endIdMilliSecondsPart &&
                                        e.getSequenceNoIdPart() >=  startIdSequenceNoPart &&
                                        e.getSequenceNoIdPart() <= endIdSequenceNoPart
                        )
                ).toList();
    }

    public String isStreamEntryValid(String streamEntryId) {
        RespStreamEntry lastStreamEntry = getLastStreamEntry();
        if (lastStreamEntry == null) return "";

        boolean isFullAutoGenerated = streamEntryId.equals("*");
        if (isFullAutoGenerated) { return ""; }

        boolean isPartialAutoGenerated = streamEntryId.split("-")[1].equals("*");

        long newStreamIdMillisecondsPart = Long.parseLong(streamEntryId.split("-")[0]);
        long lastStreamIdMillisecondsPart = Long.parseLong(lastStreamEntry.getId().split("-")[0]);
        boolean isMilliSecondPartValid = newStreamIdMillisecondsPart >= lastStreamIdMillisecondsPart;

        if (isPartialAutoGenerated && isMilliSecondPartValid) {
            return "";
        }

        if (!isPartialAutoGenerated) {
            long newStreamIdSequenceNoPart = Long.parseLong(streamEntryId.split("-")[1]);
            long lastStreamIdSequenceNoPart = Long.parseLong(lastStreamEntry.getId().split("-")[1]);

            if (newStreamIdMillisecondsPart == 0 && newStreamIdSequenceNoPart == 0) {
                return "-ERR The ID specified in XADD must be greater than 0-0\r\n";
            }

            boolean isSequenceNumberValid = newStreamIdSequenceNoPart >= lastStreamIdSequenceNoPart;;
            if (newStreamIdMillisecondsPart == lastStreamIdMillisecondsPart) {
                isSequenceNumberValid = newStreamIdSequenceNoPart > lastStreamIdSequenceNoPart;
            }

            if (!isMilliSecondPartValid || !isSequenceNumberValid) {
                return "-ERR The ID specified in XADD is equal or smaller than the target stream top item\r\n";
            }
        }
        return "";
    }

    public String createNextId(String streamEntryId) {
        StringBuilder id = new StringBuilder();
        RespStreamEntry lastStreamEntry = getLastStreamEntry();

        if (streamEntryId.equals("*")) {
            long milliSecondIdPart = System.currentTimeMillis();
            if (lastStreamEntry == null) {
                return id.append(milliSecondIdPart).append("-").append(0).toString();
            } else {
                String[] lastEntryIdParts = lastStreamEntry.getId().split("-");
                long lastEntryMillisecondIdPart = Long.parseLong(lastEntryIdParts[0]);
                if (lastEntryMillisecondIdPart == milliSecondIdPart) {
                    long lastEntrysequenceNoIdPart = Long.parseLong(lastEntryIdParts[1]);
                    return id.append(milliSecondIdPart).append("-").append(lastEntrysequenceNoIdPart + 1).toString();
                }
            }
        }

        String[] idParts = streamEntryId.split("-");
        long millisecondsPart = Long.parseLong(idParts[0]);
        long sequenceNoPart;

        if (!idParts[1].equals("*")) {
            sequenceNoPart = Long.parseLong(idParts[1]);
            return id.append(millisecondsPart).append("-").append(sequenceNoPart).toString();
        }

        if (lastStreamEntry == null) {
            sequenceNoPart = millisecondsPart == 0 ? 1L : 0L;
        } else {
            long lastEntryMillisecondsPart = Long.parseLong(lastStreamEntry.getId().split("-")[0]);
            long lastEntrySequenceNoPart = Long.parseLong(lastStreamEntry.getId().split("-")[1]);
            sequenceNoPart = millisecondsPart > lastEntryMillisecondsPart ? 0L : lastEntrySequenceNoPart + 1;
        }
        return  id.append(millisecondsPart).append("-").append(sequenceNoPart).toString();
    }

    public String getNextStreamId(String streamEntryId) {
        String[] streamEntryIdParts = streamEntryId.split("-");
        boolean idSequenceNoPartExists = streamEntryIdParts.length > 1;
        String result;

        // Exclude current stream entry adding one to it
        if (idSequenceNoPartExists) {
            long excludeCurrentStreamId = Long.parseLong(streamEntryIdParts[1]) + 1;
            result = streamEntryIdParts[0] + "-" + excludeCurrentStreamId;
        } else {
            long excludeCurrentStreamId = Long.parseLong(streamEntryIdParts[0]) + 1;
            result = Long.toString(excludeCurrentStreamId);
        }
        return result;
    }

    public class RespStreamEntry {
        String id;
        List<Map<String, Object>> streamEntries = new ArrayList<>();

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public List<Map<String, Object>> getStreamEntries() {
            return streamEntries;
        }

        public void addStreamEntry(Map<String, Object> streamEntry) {
            this.streamEntries.add(streamEntry);
        }

        public List<Long> convertStreamEntryIdToLong() {
            String[] idParts = id.split("-");
            return Arrays.stream(idParts)
                    .toList()
                    .stream()
                    .map(Long::parseLong)
                    .toList();
        }

        public long getMilliSecondsIdPart() {
            return convertStreamEntryIdToLong().getFirst();
        }

        public long getSequenceNoIdPart() {
            return convertStreamEntryIdToLong().getLast();
        }

        public RESPObject convertStreamToRedisArray() {
            ArrayList<RESPObject> streamIdEntryBulkString = new ArrayList<>();
            for (Map<String, Object> entry : streamEntries) {
                entry.forEach((k, v) -> {
                    streamIdEntryBulkString.add(new RESPBulkString(k));
                    streamIdEntryBulkString.add(new RESPBulkString(v.toString()));
                });
            }
            RESPObject entriesRedisArrRepresentation = new RESPArray(streamIdEntryBulkString);
            return new RESPArray(List.of(new RESPBulkString(id), entriesRedisArrRepresentation));
        }
    }

}